## [1. 二分查找](https://leetcode.cn/problems/binary-search/description/)

给定一个 `n` 个元素有序的（升序）整型数组 `nums` 和一个目标值 `target` ，写一个函数搜索 `nums` 中的 `target`，如果 `target` 存在返回下标，否则返回 `-1`。

你必须编写一个具有 `O(log n)` 时间复杂度的算法。


**示例 1:**

```
输入: nums = [-1,0,3,5,9,12], target = 9
输出: 4
解释: 9 出现在 nums 中并且下标为 4
```

**示例 2:**

```
输入: nums = [-1,0,3,5,9,12], target = 2
输出: -1
解释: 2 不存在 nums 中因此返回 -1
```

 

**提示：**

1. 你可以假设 `nums` 中的所有元素是不重复的。
2. `n` 将在 `[1, 10000]`之间。
3. `nums` 的每个元素都将在 `[-9999, 9999]`之间。

###  **题解：**

我直接用背过模板就好了。

```cpp
class Solution {
public:
    int search(vector<int>& nums, int target)
    {
        int l = 0, r = nums.size() - 1;
        while (l < r)
        {
            int mid = l + r >> 1;
            if (nums[mid] >= target)
                r = mid;
            else
                l = mid + 1;
        }

        if (nums[l] == target)
            return l;
        else
            return -1;
    } 
};
```

## [2. 移除元素](https://leetcode.cn/problems/remove-element/description/)

给你一个数组 `nums` 和一个值 `val`，你需要 **[原地](https://baike.baidu.com/item/原地算法)** 移除所有数值等于 `val` 的元素。元素的顺序可能发生改变。然后返回 `nums` 中与 `val` 不同的元素的数量。

假设 `nums` 中不等于 `val` 的元素数量为 `k`，要通过此题，您需要执行以下操作：

- 更改 `nums` 数组，使 `nums` 的前 `k` 个元素包含不等于 `val` 的元素。`nums` 的其余元素和 `nums` 的大小并不重要。

- 返回 `k`。

  

**示例 1：**

```
输入：nums = [3,2,2,3], val = 3
输出：2, nums = [2,2,_,_]
解释：你的函数函数应该返回 k = 2, 并且 nums 中的前两个元素均为 2。
你在返回的 k 个元素之外留下了什么并不重要（因此它们并不计入评测）。
```

**示例 2：**

```
输入：nums = [0,1,2,2,3,0,4,2], val = 2
输出：5, nums = [0,1,4,0,3,_,_,_]
解释：你的函数应该返回 k = 5，并且 nums 中的前五个元素为 0,0,1,3,4。
注意这五个元素可以任意顺序返回。
你在返回的 k 个元素之外留下了什么并不重要（因此它们并不计入评测）。
```

 

**提示：**

- `0 <= nums.length <= 100`
- `0 <= nums[i] <= 50`
- `0 <= val <= 100`

- [x] **思路1：**

题目中说==注意这五个元素可以任意顺序返回==，所以可以先进行排序，这样子所有相同的数就在一起了，然后找到val区间的起点和终点，将后面的数覆盖val区间就好了。

**题解1：暴力寻找val区间**

```cpp
class Solution {
public:
    int removeElement(vector<int>& nums, int val)
    {
        //1. 排序 使所有相同的数在一起
        sort(nums.begin(), nums.end());
        int n = nums.size();
        int i = 0, j;
        

        //找到第一个val出现的位置
        while (i < n && nums[i] != val) i++;

        //找到val最后一个出现的位置
        j = i;
        while (j < n && nums[j] == val) j++;
        

        //将后面的元素覆盖val
        while (j < n)
            nums[i++] = nums[j++];

        return i;
    }
};
```

**题解2：二分查找val区间**

但是二分的话区间需对边界进行检查，代码可读性没有第一个简单。

```cpp
class Solution {
public:
    int removeElement(vector<int>& nums, int val)
    {
        if (nums.size() == 0)
            return 0;

        //1. 排序 使所有相同的数在一起
        sort(nums.begin(), nums.end());
        int n = nums.size();
        int i, j;
        int l = 0, r = n - 1;

        //找起点
        while (l < r)
        {
            int mid = l + r >> 1;
            if (nums[mid] >= val)
                r = mid;
            else
                l = mid + 1;
        }

        
        if (nums[l] != val)
            return n;
        i = l;
		
        //找终点
        r = n - 1;
        while (l < r)
        {
            int mid = l + r + 1 >> 1;
            if (nums[mid] <= val)
                l = mid;
            else
                r = mid - 1;
        }
        j = l + 1;
        
        //将后面的元素覆盖val
        while (j < n)
            nums[i++] = nums[j++];

        return i;
    }
};
```

- [x] **思路2：双指针**

不用排序，利用双指针来做。

两个一快一慢的指针，快指针去遍历数组每个元素，只要它不和val相等则给慢指针的位置赋值。

- 快指针永远加加
- 满指针只有在快指针赋值给自己的时候加加

这种做法也叫**快慢指针**。

```cpp
class Solution {
public:
    int removeElement(vector<int>& nums, int val)
    {
        if (nums.size() == 0)
            return 0;

        int n = nums.size();
        
        int slow = 0;
        for (int fast = 0; fast < n; fast++)
        {
            if (nums[fast] != val)
                nums[slow++] = nums[fast];
        }
        
        return slow;
    }
};
```

## [3.有序数组的平方](https://leetcode.cn/problems/squares-of-a-sorted-array/description/)

给你一个按 **非递减顺序** 排序的整数数组 `nums`，返回 **每个数字的平方** 组成的新数组，要求也按 **非递减顺序** 排序。

**示例 1：**

```
输入：nums = [-4,-1,0,3,10]
输出：[0,1,9,16,100]
解释：平方后，数组变为 [16,1,0,9,100]
排序后，数组变为 [0,1,9,16,100]
```

**示例 2：**

```
输入：nums = [-7,-3,2,3,11]
输出：[4,9,9,49,121]
```

### 1. 暴力+排序

直接对数组每个元素进行求平方，然后排序即可。

```cpp
class Solution {
public:
    vector<int> sortedSquares(vector<int>& nums)
    {
      vector<int> res;
      for (int i = 0; i < nums.size(); i++)
        res.push_back(nums[i] * nums[i]);  

      sort(res.begin(), res.end());

      return res;
    }
};
```

### 2. 双指针

题目中说数组是一个升序数组，两个指针取两头，看看谁的平方大，谁往后放。

```cpp
class Solution {
public:
    vector<int> sortedSquares(vector<int>& nums)
    {
        int n = nums.size();
        vector<int> res(n);

        int l = 0, r = n - 1, k = n - 1;

        while (l <= r)
        {
            int a = nums[l] * nums[l];
            int b = nums[r] * nums[r];
            if (a > b)
            {
                res[k--] = a;
                l++;
            }
            else
            {
                res[k--] = b;
                r--;
            }
        }


        return res;
    }
};
```

## [4. 长度最小的子数组](https://leetcode.cn/problems/minimum-size-subarray-sum/)

给定一个含有 `n` 个正整数的数组和一个正整数 `target` **。**

找出该数组中满足其总和大于等于 `target` 的长度最小的 **子数组** `[numsl, numsl+1, ..., numsr-1, numsr]` ，并返回其长度**。**如果不存在符合条件的子数组，返回 `0` 。

**示例 1：**

```
输入：target = 7, nums = [2,3,1,2,4,3]
输出：2
解释：子数组 [4,3] 是该条件下的长度最小的子数组。
```

**示例 2：**

```
输入：target = 4, nums = [1,4,4]
输出：1
```

**示例 3：**

```
输入：target = 11, nums = [1,1,1,1,1,1,1,1]
输出：0
```

**提示：**

- `1 <= target <= 109`
- `1 <= nums.length <= 105`
- `1 <= nums[i] <= 104`

### 1. 暴力

直接暴力双`for`去模拟答案，但是会超时

```cpp
class Solution
{
public:
    int minSubArrayLen(int target, vector<int>& nums)
    {
        int n = nums.size();
        int res = 0X3f3f3f;
        for (int i = 0; i < n; i++)
        {
            int sum = nums[i];
            if (sum >= target)
                return 1;
            
            for (int j = i + 1; j < n; j++)
            {
                sum += nums[j];
                if (sum >= target)
                {
                    res = min(res, j - i + 1);
                    break;
                }
            }
        }

        return res == 0X3f3f3f ? 0 : res;
    }
};
```

### 2. 滑动窗口

这个思路本质上还是双指针实现，利用前后指针维护一个`res`区间出来,这个区间是需要动态维护的。

滑动窗口 = 双指针 + 维护一个区间状态（和、频次等）。

- 维护一个[i, j] 的区间，区间内的和要是小于`target` 就新增数字，使`j++`;
- 当区间和大于等于`target`的话，为了求最小的长度，我们需要收缩区间，使`i++`;

```cpp
class Solution
{
public:
    int minSubArrayLen(int target, vector<int>& nums)
    {
        int n = nums.size();
        int res = 0X3f3f3f;
        int sum = 0;
        for (int i = 0, j = 0; j < n; j++)
        {
            sum += nums[j];
            while (i <= j && sum >= target)
            {
                res = min(res, j - i + 1);
                sum -= nums[i++];
            }
        }
        return res == 0X3f3f3f ? 0 : res;
    }
};
```

## [5.螺旋矩阵II](https://leetcode.cn/problems/spiral-matrix-ii/submissions/654228778/)

给你一个正整数 `n` ，生成一个包含 `1` 到 `n2` 所有元素，且元素按顺时针顺序螺旋排列的 `n x n` 正方形矩阵 `matrix` 。

**示例 1：**

![img](https://cdn.jsdelivr.net/gh/Kxq-xl/pic-bed/img/spiraln.jpg)

```
输入：n = 3
输出：[[1,2,3],[8,9,4],[7,6,5]]
```

**示例 2：**

```
输入：n = 1
输出：[[1]]
```

**提示：**

- `1 <= n <= 20`

### 模拟

按照左闭右开的区间去填充每个数字.

- `offSet` 的作用是控制 **每一层螺旋的边界缩进**

```cpp
class Solution {
public:
    vector<vector<int>> generateMatrix(int n)
    {
        vector<vector<int>> res(n, vector<int> (n, 0));
        int startX = 0, startY = 0;
        int i, j;
        int cnt = 1, offSet = 1;
        //左闭右开[x, y)
        for (int k = 0; k < n / 2; k++, startX++,startY++,offSet++)
        {
            // 从左往右
            for (j = startY; j < n - offSet; j++)
                res[startX][j] = cnt++;
            
            // 从上往下
            for (i = startX; i < n - offSet; i++)
                res[i][j] = cnt++;

            // 从右往左
            for (j; j > startY; j--)
                res[i][j] = cnt++;
            
            for (i; i > startX; i--)
                res[i][j] = cnt++;
        }

        if (n % 2)
            res[startX][startY] = cnt;
 
        return res;
    }
};
```

## [6. 区间和](https://kamacoder.com/problempage.php?pid=1070)

**题目描述**

给定一个整数数组 Array，请计算该数组在每个指定区间内元素的总和。

**输入描述**

第一行输入为整数数组 Array 的长度 n，接下来 n 行，每行一个整数，表示数组的元素。随后的输入为需要计算总和的区间下标：a，b （b > = a），直至文件结束。

**输出描述**

输出每个指定区间内元素的总和。

**输入示例**

```
5
1
2
3
4
5
0 1
1 3
```

**输出示例**

```
3
9
```

**提示信息**

数据范围：
0 < n <= 100000

### 前缀和

利用前缀和公式`s[l, r] = s[r] - s[l - 1];` 注意下标从1开始存

```cpp
#include <iostream>

using namespace std;

const int N = 1e5 + 10;

int n;
int a[N], s[N];

int main()
{
    cin >> n;
    for (int i = 1; i <= n; i++)
    {
        cin >> a[i];
        s[i] = s[i - 1] + a[i];
    }

    int l, r;
    while (cin >> l >> r)
    {
        //因为我下标从 1开始存储
        l += 1;
        r += 1;

        cout << s[r] - s[l - 1] << endl;
       
    }

    return 0;
}
```

## [7. 开发商购买土地](https://kamacoder.com/problempage.php?pid=1044)

**题目描述**

在一个城市区域内，被划分成了n * m个连续的区块，每个区块都拥有不同的权值，代表着其土地价值。目前，有两家开发公司，A 公司和 B 公司，希望购买这个城市区域的土地。 

现在，需要将这个城市区域的所有区块分配给 A 公司和 B 公司。

然而，由于城市规划的限制，只允许将区域按横向或纵向划分成两个子区域，而且每个子区域都必须包含一个或多个区块。 为了确保公平竞争，你需要找到一种分配方式，使得 A 公司和 B 公司各自的子区域内的土地总价值之差最小。 

注意：区块不可再分。

**输入描述**

第一行输入两个正整数，代表 n 和 m。 

接下来的 n 行，每行输出 m 个正整数。

**输出描述**

请输出一个整数，代表两个子区域内土地总价值之间的最小差距。

**输入示例**

```
3 3
1 2 3
2 1 3
1 2 3
```

**输出示例**

```
0
```

**提示信息**

如果将区域按照如下方式划分：

1 2 | 3
2 1 | 3
1 2 | 3 

两个子区域内土地总价值之间的最小差距可以达到 0。

**数据范围：**

1 <= n, m <= 100；
n 和 m 不同时为 1。

### 前缀和

这道题利用二维前缀和，因为题目中提到只能整行(列)切割，所以我们枚举出所有的可能就好了。

中间可以用公式优化
$$
|sum_{top} - sum_{bottom}| 
= |s[i][m] - (s[n][m] - s[i][m])| 
= |s[n][m] - 2 \times s[i][m]|
$$
![image-20250818202954902](https://cdn.jsdelivr.net/gh/Kxq-xl/pic-bed/img/image-20250818202954902.png)

```cpp
#include <iostream>

using namespace std;


const int N = 110;

int s[N][N];

int n, m;


int main()
{
    cin >> n >> m;
    
    for (int i = 1; i <= n; i++)
        for (int j = 1; j <= m; j++)
        {
            int x;
            cin >> x;
            s[i][j] = s[i - 1][j] + s[i][ j - 1] - s[i - 1][j - 1] + x;
        }
    
    int ans = 0x3f3f3f;

    //行矩阵分隔
    for (int i = 1; i <= n; i++)
    {
        //abs(s[i][m] - (s[n][m] - s[i][m]));
        // = abs (s[i][m] - s[n][m] + s[i][m])
        // = abs (s[n][m] - 2 * s[i][m])

        int t = abs(s[n][m] - 2 * s[i][m]);
        ans = min(ans, t);
    }
    //列矩阵
    for (int j = 1; j <= m; j++)
    {
        int t = abs(s[n][m] - 2 * s[n][j]);
        ans = min(ans, t);
    }


    cout << ans << endl;

    return 0;
}
```

----



