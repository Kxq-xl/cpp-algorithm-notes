# 1. 排序

## 1.1 快速排序

快排的主要思想是分治。

- 在数组中随便找一个值作为分界点，常见的，取左边界，中间值，右边界
- 调整区间: 根据x的值，把区间分为两段，使的第一个区间内的数全部小于等于x，第二个区间内的数全都大于等于x。
- 递归处理左右两边。

![image-20250808084808956](https://cdn.jsdelivr.net/gh/Kxq-xl/pic-bed/img/image-20250808084808956.png)

## 1.2 归并算法

归并排序的主要思想也是分治。

- 以中心为分界点，分为左边和右边。
- 然后递归两边。
- 将两个有序的数组，合并成一个有序的数组。

# 2. 二分

有单调性的题目一定可以二分，没有单调性的题目，也有可能二分，所以二分的本质并不是单调性。

二分的本质: 我们可以在一个区间内，找到一个点(性质)，然后利用这个性质，将区间一分为二，使一个区间内全满足这个性质，另一个区间内不满足这个性质。

# 3. 前缀和与差分

### 3.1 前缀和

前缀和是用来快速计算某个区间内**元素和**的技巧

核心思想：

- 先预处理出一个数组 `prefix[]`，其中 `prefix[i]` 表示原数组**从开头到第 i 个元素的总和**。
- 这样要计算任意区间 `[l, r]` 的和时，不用再一个个加，只需要：

`sum(l,r)=prefix[r]−prefix[l−1]`

![image-20250812154343165](https://cdn.jsdelivr.net/gh/Kxq-xl/pic-bed/img/image-20250812154343165.png)

二维前缀和也是有的

- 计算公式`prefix[i][j]=prefix[i−1][j]+prefix[i][j−1]−prefix[i−1][j−1]+a[i][j]`

- 求和公式要求 `(x1, y1)` 到 `(x2, y2)` 这个矩形的和：

  `sum=prefix[x2][y2]−prefix[x1−1][y2]−prefix[x2][y1−1]+prefix[x1−1][y1−1]`

### 3.2 差分

差分其实是**前缀和的逆运算技巧**，它的用途是：**快速对一个数组的某个区间做加减更新**。

差分数组的构造本质是利用`diff[i] = a[i] - a[i - 1](a[0] = 0)`  

如果你想让区间 `[l, r]` 的每个数都加上 `c`，只需：`d[l] += c , d[r + 1] -= c`

我们在构造差分数组的时候还可以利用一个技巧来构造,记忆的时候 只需要记忆如何更新就行了，构造的时候原地插入当前的数就好了。

```cpp
//在l~r区间的数加上C
void insert(int l, int r, int c)
{
    d[l] += c;
    d[r + 1] -= c;
} 	
//构造差分数组
//1. 公式构造
for (int i = 1; i <= n; i++)
    d[i] = a[i] - a[i - 1];
//2. 技巧构造
for (int i = 1; i <= n; i++)
    insert(i,i, a[i]);
```

二维差分插入数C:

```cpp
void insert(int x1, int y1, int x2, int y2, int c)
{
    d[x1][y1] += c;
    d[x1][y2 + 1] -= c;
    d[x2 + 1][y1] -= c;
    d[x2 + 1][y2 + 1] += c;
}
```

✅ **总结对比**：

- **前缀和**：快速求区间和（多次查询高效）。
- **差分**：快速修改区间值（多次更新高效）。

# 4. 双指针

双指针（Two Pointers）是一种常用的算法技巧，核心思想就是**用两个指针（下标变量）来同时遍历数组/链表等数据结构，从而在 O(n) 时间内解决一些问题**。

双指针可以分别指向**两个序列**或者同时指向**一个序列中**的元素

- **两个指针**可以指向同一个数组/链表的不同位置。
- 通过**移动指针**，来控制遍历的范围，减少不必要的重复计算。

常见形式：

1. **左右指针**
   - 一个从左往右走，一个从右往左走。
   - 适用于**有序数组查找**、**反转数组**、**区间问题**等。
2. **快慢指针**
   - 一个走得快，一个走得慢。
   - 适用于**链表判环**、**删除链表节点**、**寻找中点**等。
3. **滑动窗口**
   - 左指针和右指针一起向右移动，动态维护一个窗口范围。
   - 适用于**连续子数组问题**，比如“最长不重复子串”。

这算法主要的核心就是可以将一个O(n²) 暴力枚举 优化成**O(n)**。

# 5. 离散化

离散化（Discretization）是一种**数据预处理技巧**，主要作用是：
 把**值域很大**（甚至很稀疏）的数据，映射到**较小、连续的整数范围**，以便更高效地用数组、前缀和、树状数组、线段树等结构处理。

在算法题里，经常会遇到这种情况：

- 数据的值域特别大，比如坐标是 `[-10^9, 10^9]`。
- 但真正用到的数可能只有几十个或几百个。
- 如果直接开数组按原值下标存，就会浪费大量内存。

解决办法：
 **把用到的数重新编号**，让它们落在 `[1, n]` 这样的连续小范围里。