# 1. 操作系统概述

## 1.1 操作系统的基本概念

###  1.1.1 操作系统的概念

**操作系统是计算机的“管理者”和“中介”**，它负责协调和控制计算机的各种资源（如 CPU、内存、硬盘、输入输出设备等），同时向上为用户和程序提供一个**友好、统一的操作接口**。

**常见功能包括：**

1. **进程管理**：
    管理程序的运行，包括进程创建、调度、终止等。
2. **内存管理**：
    控制和分配内存资源，确保各程序合理使用内存，互不干扰。
3. **文件系统**：
    提供文件的创建、读写、存储等功能，便于数据管理。
4. **设备管理**：
    管理各种输入输出设备，如硬盘、打印机、键盘等。
5. **用户接口**：
    提供命令行或图形界面，让用户能与计算机交互。

常见的操作系统有: **Windows ** **Linux ** **macOS ** **Android / iOS（移动设备）**

### 1.1.2 操作系统的功能和目标

操作系统作为计算机系统资源的管理者

- 处理机管理
- 存储器管理
- 文件管理
- 设备管理

![image-20250807183551941](https://cdn.jsdelivr.net/gh/Kxq-xl/pic-bed/img/image-20250807183551941.png)

![image-20250807185430547](https://cdn.jsdelivr.net/gh/Kxq-xl/pic-bed/img/image-20250807185430547.png)

### 1.1.3 操作系统的特征

操作系统的特称： 并发 ，共享，虚拟，异步。

- **并发:**  指两个或者多个事件在同一时间间隔内发生，这些事件**宏观上是同时发生的**，但**微观上是交替发生的**。并行：是指两个时间在同一时刻同时发生。

![image-20250807191349209](https://cdn.jsdelivr.net/gh/Kxq-xl/pic-bed/img/image-20250807191349209.png)

**注意:**

单核CPU**同一时刻只能执行一个程序**，各个程序**并发**的执行。

多核CPU**同一时刻能执行多个程序**，多个程序可以**并行**执行。

- **共享**：共享即多个事件发生的时候，共同使用。资源共享主要分为**互斥共享**和**同时共享**。

微信和qq不能同时视频，这个就是互斥共享，不能同时占用摄像头。

但是可以同时发送文件，同时发送文件在宏观上是同时读取，同时发送，但并不是同时共享，它在微观上，两个进程是交替着访问硬盘的，这里传一会儿，那里传一下。所以磁盘是可共享资源，但访问是以并发+交替调度方式进行的

我们如果一遍打游戏，一遍听歌，这个扬声器确实是同时共享

**并发和共享是互为存在的条件**，只有并发了你才可以共享，你共享了，就必须并发才行。

- **虚拟： **把一个物理上的实体变为若干个逻辑上的对应物。物理实体(前者)是实际存在的，而逻辑上对应物（后者）是用户感受到的。

比如4g的内存，但你却能打开好多程序，他们运行内存远远大于4gb，这就是虚拟存储器技术。实际上只有4g，但用户看起来很大。 ------ 空分复用技术。

比如我们一个单核的CPU，物理上我们只能打开一个程序，但是逻辑上我们仍然可以打开很多很多的程序。 ----- 时分复用技术。

 ![image-20250807194931611](https://cdn.jsdelivr.net/gh/Kxq-xl/pic-bed/img/image-20250807194931611.png)

- **异步：**在多道程序环境下，允许多个程序并发执行，但由于资源有限，进程的执行不是一贯到底的，而是走走停停，以不可预知的速度向前推进，这就是进程的异步性。

你需要打印文档A和B, 总有个先后，先打印A B则等待，系统资源有限，因此进程的执行不是一贯到底的。

## 1.2 操作系统的发展与分类

![image-20250808153041562](https://cdn.jsdelivr.net/gh/Kxq-xl/pic-bed/img/image-20250808153041562.png)

## 1.3 操作系统的运行环境

### 1.3.1 操作系统的运行机制

在操作系统中，cpu上会运行两种程序，一种是操作系统的**内核程序**，另一种是用户编写的**应用程序**。

**两种指令:**

- 特权指令: 是指不允许用户直接使用的指令，I/O指令，内存清零，修改程序状态寄存器等指令
- 非特权指令: 用户可以直接使用的指令，它不能直接访问系统的软硬件资源，防止破坏系统。

两种处理器状态：

- 内核态：运行的是内核程序，此时可以执行特权指令

- 用户态： 运行的是应用程序，只能执行非特权指令。

CPU中有一个寄存器叫做程序状态字寄存器(psw) 其中有一个二进制位，`1`表示内核态` 0`表示用户态。有些 CPU 设计是反过来的（比如 `0` 表示内核态，`1` 表示用户态），**具体取值要看 CPU 架构手册**。

![image-20250808161040012](https://cdn.jsdelivr.net/gh/Kxq-xl/pic-bed/img/image-20250808161040012.png)

### 1.3.2 中断和异常

在合适的情况下，操作系统内核会把cpu的使用权主动让给应用程序。

中断是让操作系统给内核夺回cpu使用权的**唯一途径**，中断会使cpu由用户态变为内核态。

中断分为**内中断（异常）**和**外中断**

- 内中断: 与当前执行的指令有关，中断信号来源于cpu内部。

试图在用户态下执行特权指令，当前的指令是非法的(**终止**)，或者参数是非法的(**故障**)。

应用程序想请求操作系统内核服务，此时会执行一条**陷入指令**，该指令会引发一个内部中断信号，**系统调用就是通过陷入指令完成的**。

- 外中断: 与当前执行的指令无关，中断信号来源于cpu外部。

时钟中断，I/O中断。

![image-20250808170047574](https://cdn.jsdelivr.net/gh/Kxq-xl/pic-bed/img/image-20250808170047574.png)

### 1.3.3 系统调用

系统调用是操作系统提供给程序(程序员)使用的接口。

系统调用的功能:

- 设备管理
- 文件管理
- 进程控制
- 进程通信
- 内存管理

![image-20250808172557614](https://cdn.jsdelivr.net/gh/Kxq-xl/pic-bed/img/image-20250808172557614.png)

![image-20250808172624360](https://cdn.jsdelivr.net/gh/Kxq-xl/pic-bed/img/image-20250808172624360.png)

## 1.4 操作系统体系结构

操作系统的体系结构有大内核(宏内核)，微内核，分层结构，模块化，外核。

- 分层结构： 每层单向调用更低一层所提供的接口，便于调试，易维护，但是效率低，不可跨层调用，效率低。
- 模块化：每个模块之间相互独立，有着清晰的结构，但是模块之间可能会出现相互调用的情况，一旦出了问题，调试和验证会有点麻烦。
- 大内核:  高性能，但是结构混乱，难以维护
- 微内核： 内核功能少，方便维护，但是多次状态切换，性能低。
- 外核: 可以直接给用户进程分配不虚拟不抽象的硬件资源，使用户进程更灵活的使用硬件资源，但它降低了系统的一致性，使系统变得复杂。

![image-20250811174934154](https://cdn.jsdelivr.net/gh/Kxq-xl/pic-bed/img/image-20250811174934154.png)

![image-20250811175156226](https://cdn.jsdelivr.net/gh/Kxq-xl/pic-bed/img/image-20250811175156226.png)

## 1.5 操作系统的引导

计算机中的主存由RAM(内存)和ROM组成。

| 对比项       | RAM（内存）              | ROM（只读存储器）                |
| ------------ | ------------------------ | -------------------------------- |
| 是否可写     | 读写都行（运行时可改）   | 一般只读（某些可擦写）           |
| 断电是否丢失 | 丢失（易失性）           | 不丢失（非易失性）               |
| 速度         | 很快                     | 较慢                             |
| 主要用途     | 存放正在运行的程序和数据 | 存放启动程序和固件(BIOS)自举程序 |
| 位置         | 内存条8G, 16G 32G        | 焊在主板上的芯片                 |

开机通电，cpu去找主存，然后里面的ROM引导程序会指示cpu去磁盘首位置将主引导记录和分区表读入到RAM(内存中去) 

然后cpu执行磁盘引导程序，然后根据分区表，去判断C盘所处的位置，然后在C盘中找到引导记录PBR，它会负责找到启动管理，在根目录下找到启动管理程序，然后就会完成操作系统初始化的工作。

![image-20250811194744778](https://cdn.jsdelivr.net/gh/Kxq-xl/pic-bed/img/image-20250811194744778.png)

## 1.6 虚拟机

![image-20250812105818489](https://cdn.jsdelivr.net/gh/Kxq-xl/pic-bed/img/image-20250812105818489.png)



## 总结：✅ **操作系统第1章 速记表**

### **1. 操作系统的定义与作用**

- **定义**：操作系统是管理计算机硬件与软件资源、提供用户和程序接口的系统软件。
- **作用**：
  1. 作为**用户与硬件的接口**（命令行、GUI）
  2. 作为**资源管理者**（CPU、内存、文件、设备等）
  3. 提供**服务**（系统调用、库函数）

------

### **2. 操作系统的特征**

- **并发性**：多个程序宏观上同时运行，微观上分时交替执行。
- **共享性**：系统资源可被多个用户或程序共同使用（互斥共享 & 同时共享）。
- **虚拟性**：通过抽象技术，让有限资源看起来更大或更简单（如虚拟内存、虚拟处理器）。
- **异步性**：进程执行走走停停，由 OS 调度，但结果可预测。

------

### **3. 操作系统的主要功能**

1. **进程管理**：进程/线程控制、调度、同步与通信。
2. **存储管理**：内存分配与回收、虚拟内存管理。
3. **文件管理**：文件存储、目录管理、访问控制。
4. **设备管理**：设备分配、驱动程序、中断处理。

------

### **4. 系统调用 vs API**

- **系统调用（System Call）**：
  - OS 提供给用户程序访问内核功能的**唯一接口**。
  - 通过陷入指令从用户态切换到内核态执行。
  - 例：`read()`, `write()`, `fork()`（Linux）
- **API（Application Programming Interface）**：
  - 应用程序调用的**函数接口**，可能封装了系统调用。
  - 例：C 标准库函数 `printf()` 内部会调用 `write()` 系统调用。
- **关系**：
   API 是高层接口，系统调用是 OS 提供的底层接口；API 可以调用系统调用，但不等于系统调用。
### **5. 并发 vs 并行**

- **并发（Concurrency）**：宏观同时、微观交替执行（单核 CPU 也能做到）。
- **并行（Parallelism）**：真正的同时执行（需要多核/多处理器）。

例子：

- 并发：一个 CPU 交替处理两个进程，看起来像同时进行。
- 并行：两个 CPU 核心分别同时执行两个进程。

------

### **6. 操作系统如何实现虚拟？**

- **虚拟内存**：用磁盘空间扩展物理内存，并给进程提供连续的地址空间抽象。
- **虚拟处理器**：多道程序设计，让每个进程看起来像独占 CPU。
- **虚拟设备**：用统一接口（驱动 + 虚拟文件系统）操作不同物理设备。

---

# 2. 进程管理

## 2.1 进程和线程

### 2.1.1 进程的概念和组成

- 程序: 放在磁盘里面的可执行文件，是==静态==的。

- 进程: 是程序的一次执行过程， 是==动态==的。

当一个进程被创建的时候，操作系统会为此程序创建一个**唯一**的，**不重复**的ID --- **PID**。

**UID** 就是进程所属的用户。

![image-20250813164833849](https://cdn.jsdelivr.net/gh/Kxq-xl/pic-bed/img/image-20250813164833849.png)

上面所说的PID UID 以及图片中的cpu，磁盘，内存等等 都需要放在一个**进程控制块中(PCB)** PCB是进程存在的**唯一标志**。

![image-20250813165156689](https://cdn.jsdelivr.net/gh/Kxq-xl/pic-bed/img/image-20250813165156689.png)

**进程的组成: ** PCB、程序段、数据段。

PCB，是给操作系统用的，程序段和数据段是进程给自己用的。	

![image-20250813165918923](https://cdn.jsdelivr.net/gh/Kxq-xl/pic-bed/img/image-20250813165918923.png)

程序段、数据段、PCB三部分组成了进程实体(进程映像)。

进程是进程实体的运行过程，是系统进行资源分配和调度的一个单位。

### 2.1.2 进程的特征

程序是静态的，进程是动态的，相比于程序，进程拥有一下特征：

- 动态性：进程是程序的一次执行过程，是动态产生的，变化和消亡的。
- 并发性：内存中有个进程实体，各进程可以并发执行。
- 独立性：进程是能独立运行，独立获得资源，独立接受调度的基本单位
- 异步性：各进程各自独立的，不可预知的速度向前推进
- 结构性：每个进程都配置一个PCB，都由程序段和数据段 PCB组成。

### 2.1.3 进程的状态与转化

![image-20250813171633226](https://cdn.jsdelivr.net/gh/Kxq-xl/pic-bed/img/image-20250813171633226.png)

**状态：**

- 创建态：进程正在被创建，这个阶段操作系统会为进程分配资源，初始化PCB。
- 就绪态：进程已经创建完毕了，但由于没有空闲的CPU，就暂时不运行。
- 运行态：当CPU空闲下来，操作系统就会从处于就绪态的进程中，选择一个，进行运行，就叫运行态。
- 阻塞态：在进程运行中，有可能会**请求某个事件的发生**，所以在这个事件发生之前，CPU会使这个进程下去，让他变位阻塞态，然后CPU再选择一个就绪态的进程。当它等待的事情发生后，这个进程就又变回就绪态。
- 终止态：一个进程执行`exit` 请求操作系统终止进程，此时进程进入了终止态，然后让该进程下CPU，并回收内存空间等资源，最后回收PCB。

![image-20250813174231156](https://cdn.jsdelivr.net/gh/Kxq-xl/pic-bed/img/image-20250813174231156.png)

### 2.1.4 进程控制

进程控制就是 OS 用**原语**通过 PCB 对进程的**创建、运行、阻塞、唤醒、终止**进行管理，确保多进程在系统中**安全、高效、有序**地运行。

原语的执行必须一气呵成，不可中断。

**进程的创建**

- 分配进程控制块（PCB）
- 分配所需的内存和资源
- 初始化寄存器、程序计数器等运行环境
- 典型调用：`fork()`（Linux）

**进程的终止**

- 回收资源（内存、文件描述符等）
- 销毁 PCB
- 通知父进程进程结束状态

**进程的阻塞与唤醒**（成对出现）

- **阻塞**：进程等待某个事件（I/O 完成、信号等）而暂停运行
- **唤醒**：事件发生后让阻塞进程重新进入就绪队列

**进程的切换（上下文切换）**

- 保存当前进程的 CPU 环境（寄存器值、程序计数器等）
- 恢复下一个进程的运行环境

| 控制动作              | PCB 状态变化                       | 队列变化         |
| --------------------- | ---------------------------------- | ---------------- |
| **创建**（Create）    | 新建 PCB → 初始化状态              | 加入**就绪队列** |
| **撤销**（Terminate） | 释放 PCB → 回收资源                | 从所有队列移除   |
| **阻塞**（Block）     | 状态改为阻塞                       | 移入**阻塞队列** |
| **唤醒**（Wakeup）    | 状态改为就绪                       | 加入**就绪队列** |
| **切换**（Dispatch）  | 保存当前 PCB 寄存器值 → 加载新 PCB | 运行队列切换     |

无论哪个进程控制原语，要做的无非三类事情。

1. 更新PCB中信息
2. 将PCB插入合适的队列
3. 分配/回收资源

进程控制 = **PCB + 原语 + 队列管理**

### 2.1.5 进程通信(IPC)

进程间通信就是指两个进程或者多个进程之间产生的数据交互，

- 高级通信: **共享存储**，**消息传递**，**管道通信**, **套接字（Socket)(网络通信机制)**
- 低级通信: **信号量**，**信号**。

#### **高级通信**（侧重数据传输）

**共享存储：**

- 基于**数据结构**的共享：规定的类型，规定的长度，这种方式速度慢，限制多，是一种**低级通信**方式
- 基于**存储区**的共享：操作系统在内存中划出一块共享存储区，数据形式，存放位置都由进程控制，这种方式速度快，是一种**高级通信**方式。

**消息传递：**

- **直接通信**方式：消息发送进程要指明接受进程的ID

![image-20250814171206892](https://cdn.jsdelivr.net/gh/Kxq-xl/pic-bed/img/image-20250814171206892.png)

- **间接通信**方式：通过"信箱"间接地通信,可以多个进程往同一个信箱send消息，也可以从多个进程receive消息。

![image-20250814174123208](https://cdn.jsdelivr.net/gh/Kxq-xl/pic-bed/img/image-20250814174123208.png)

**管道通信：** 管道通信的管道是一个先进先出的队列(循环队列）。

- 管道的数据流向是一个单向的，称为**半双工通信**

![image-20250814180128171](https://cdn.jsdelivr.net/gh/Kxq-xl/pic-bed/img/image-20250814180128171.png)

- 如果要实现双向同时通信，则需要两个管道，称为**全双工通信**。

![image-20250814180025519](https://cdn.jsdelivr.net/gh/Kxq-xl/pic-bed/img/image-20250814180025519.png)

1. 各个进程要**互斥的**访问管道。
2. 当**管道写满**时，写进程将**阻塞**，直到读进程将管道的数据取走，即可唤醒写进程。
3. 当**管道读空**时，读进程将**阻塞**，直到写进程往管道中写入数据，就可唤醒读进程。

![image-20250814180927052](https://cdn.jsdelivr.net/gh/Kxq-xl/pic-bed/img/image-20250814180927052.png)

#### **低级通信**（侧重同步 & 事件通知）

- 信号量 - 实现进程的同步，互斥。
- 信号 - 实现进程间通信。

信号用于通知进程某个特定的事件已经发生。进程收到一个信号后，对该信号进行处理。

1️⃣ 什么是信号

- 信号是**软件中断**，用于通知进程发生了某种事件。
- 可以由 **内核** 或 **其他进程** 发送。
- 被发送的进程**不需要提前等着**，它会在执行过程中被打断去处理信号，所以叫**异步**。

------

2️⃣ 信号的来源

1. **内核产生**
   - 硬件异常：除零错误 → `SIGFPE`
   - 访问非法内存：`SIGSEGV`
   - 子进程结束：`SIGCHLD`
2. **用户进程产生**
   - 通过系统调用 `kill()` 给某进程发信号
   - 通过终端快捷键：
     - `Ctrl+C` → `SIGINT`（中断）
     - `Ctrl+Z` → `SIGTSTP`（暂停）

------

3️⃣ 信号的常见类型（Linux）

| 信号名    | 编号 | 含义                               |
| --------- | ---- | ---------------------------------- |
| `SIGINT`  | 2    | 终端中断（Ctrl+C）                 |
| `SIGKILL` | 9    | 强制杀死进程（不可捕获、不可忽略） |
| `SIGTERM` | 15   | 终止进程（可处理）                 |
| `SIGSTOP` | 19   | 暂停进程（不可捕获）               |
| `SIGSEGV` | 11   | 段错误（非法内存访问）             |

------

4️⃣ 信号的处理方式

每当从内核态要转为用户态时，就会处理这些信号，进程可以选择：

1. **执行默认动作**（比如终止、暂停等）
2. **捕获信号**（自定义**信号处理函数**去处理）
3. **忽略信号**（除 `SIGKILL` 和 `SIGSTOP` 外）

------

5️⃣ 信号的作用

- **进程控制**：杀死、暂停、恢复进程
- **事件通知**：告诉进程某事件发生（如 I/O 完成）
- **错误处理**：异常情况立即打断进程执行

------

📌 **一句话记忆**
 信号 = 软件世界的“快递员”，异步送来事件通知，让进程立即响应，常用于控制和通知。

### 2.1.6 线程和多线程模型

**线程**是一个基本**CPU执行单元**，也是**程序执行流的最小单位**，引入线程后，不仅是进程之间可以**并发**，进程内的各**线程之间也可以并发**，从而进一步提升了**系统的并发性。**

![image-20250815130725938](https://cdn.jsdelivr.net/gh/Kxq-xl/pic-bed/img/image-20250815130725938.png)

**线程的主要属性**

1. **轻量级（Lightweight）**
   - 线程依赖进程而存在，创建/切换开销比进程小。
   - 同一进程内的线程共享资源（代码段、数据段、文件等）。
2. **共享性（Sharing）**
   - 同一进程的线程共享进程资源：
     - 地址空间
     - 打开的文件
     - 全局变量、堆内存
   - 但每个线程有自己的**栈**和**寄存器环境**，保证独立执行。
3. **独立性（Independence）**
   - 尽管共享资源，每个线程都有独立的执行流（程序计数器 PC + 栈）。
   - 一个线程崩溃可能影响整个进程（这是它和进程最大的区别）。
4. **并发性（Concurrency）**
   - 同一进程内多个线程可以并发执行。
   - 在多核 CPU 上，多个线程甚至可以**并行**运行。
5. **可调度性（Schedulability）**
   - 线程是操作系统调度的基本单位（多数现代 OS 都是**以线程为最小调度单位**）。
   - 每个线程可以有自己的优先级。
6. **轻便性（低开销）**
   - 线程切换时只需保存/恢复寄存器和栈指针，不涉及整个进程的上下文，所以效率高。

------

**📌 一句话总结**

线程 = 进程里的“小兵”：

- 共享资源（吃同一锅饭），
- 有自己独立的栈和执行流（各干各的活），
- 是操作系统调度的最小单位。



线程的实现方式: 用户级线程，内核级线程，混合实现。

- **1. 用户级线程：** 线程由**用户态的线程库**管理，操作系统内核并不知道有这些线程。

![](https://cdn.jsdelivr.net/gh/Kxq-xl/pic-bed/img/image-20250816085519309.png)

- [x]  优点：用户级线程的切换在用户空间即可完成，不需要切换到和心态，线程管理的系统开销小，效率高。

- [ ] 缺点： 如上图中while循环中，要是有一个线程被阻塞，其他的线程也无法进行下去，所以并发度不高，多线程不可在多核处理机上并行运行。

- **2. 内核级线程：** 线程由**操作系统内核管理和调度**。内核为每个线程维护控制块

![image-20250816091314443](https://cdn.jsdelivr.net/gh/Kxq-xl/pic-bed/img/image-20250816091314443.png)

- [x] 优点: 当一个线程被阻塞后，别的线程还可以继续执行，并发能力强，多线程在多核处理机上并行执行。
- [ ] 一个用户进程会占用多个内核线程，线程切换由操作系统内核完成，需要切换到核心态，因此线程管理的成本高，开销大。

- **3. 混合实现：**

**一对一模型**就是内核级线程。

**多对一模型**就是用户级线程。

**多对多模型：**用户线程不直接一一对应内核线程，而是通过运行时系统调度映射过去。 折中方案，结合了灵活性和高效性。

![image-20250816092549721](https://cdn.jsdelivr.net/gh/Kxq-xl/pic-bed/img/image-20250816092549721.png)

![image-20250816092622163](https://cdn.jsdelivr.net/gh/Kxq-xl/pic-bed/img/image-20250816092622163.png)

线程的状态迁移和进程几乎一样：

- **新建 → 就绪 → 运行 →（阻塞 ↔ 就绪）→ 终止**

---

### ✅ 进程 vs 线程区别表

| 对比维度     | **进程（Process）**                                      | **线程（Thread）**                                     |
| ------------ | -------------------------------------------------------- | ------------------------------------------------------ |
| **基本概念** | 资源分配的最小单位                                       | 程序执行的最小单位，依赖进程存在                       |
| **调度单位** | 进程是早期操作系统的调度单位                             | 现代操作系统以线程作为基本调度单位                     |
| **资源拥有** | 拥有独立的地址空间、文件描述符、代码段、数据段等         | 共享进程的资源（地址空间、文件），但有独立的栈和寄存器 |
| **开销**     | 创建/撤销开销大，切换需要保存整个进程上下文              | 创建/撤销开销小，切换只需保存少量寄存器和栈指针        |
| **通信方式** | 需要借助 IPC（管道、消息队列、共享内存、信号等），开销大 | 共享内存（全局变量、堆）即可直接通信，简单高效         |
| **健壮性**   | 一个进程崩溃通常不会影响其他进程                         | 一个线程崩溃可能导致整个进程崩溃                       |
| **并发性**   | 进程之间可并发执行                                       | 一个进程内多个线程可并发执行                           |
| **典型应用** | 系统中的独立应用（浏览器、IDE、数据库服务）              | 应用内的任务单元（浏览器的标签页、IDE 的后台编译线程） |

------

📌 **一句话记忆**：

- 进程是“大房子”，线程是“房子里的工人”。
- 进程间**相互独立**，线程间**共享资源**。
- 调度和执行粒度 → **线程更轻量，更灵活**。

## 2.2 CPU调度

### 2.2.1 调度的概念

当有一堆任务要处理时候，但资源有限，这些事情没法同时处理，这就需要确定某种规则来决定处理这些任务的顺序，这就是**调度**研究的问题。

**调度的三个层次:**

- 高级调度(作业调度): 按一定的原则从外存的作业后备队列中挑选一个作业调入内存，并创建进程。**每个作业只调入一次，调出一次。**
- 中级调度(内存调度): 按照某种策略决定将哪个处于挂起状态的进程重新调入内存。
- 低级调度(进程调度): 按照某种策略从就绪队列中选取一个进程，将处理机分配给它。

暂时调到外村等待的进程状态为**挂起状态**。

![image-20250818145834360](https://cdn.jsdelivr.net/gh/Kxq-xl/pic-bed/img/image-20250818145834360.png)

![image-20250818150039849](https://cdn.jsdelivr.net/gh/Kxq-xl/pic-bed/img/image-20250818150039849.png)

### 2.2.2 进程调度的时机切换与过程调度方式

#### **进程调度的时机（需要调度时）**

操作系统会在以下情况触发调度器，从就绪队列中选一个新进程上 CPU：

1. **进程正常结束**
   - 进程运行完成，释放 CPU，需要选择下一个进程。
2. **进程阻塞**
   - 因 I/O 请求、等待事件、获取不到资源等进入阻塞状态。
3. **进程主动放弃 CPU**
   - 调用 `sleep()`、`yield()` 等，自己让出 CPU。
4. **时间片用完**（抢占式调度）
   - 分时系统里，当进程的时间片耗尽，系统强制切换。
5. **有更高优先级的进程就绪**
   - 抢占式调度策略下，高优先级进程到达，低优先级进程被剥夺 CPU。

**❌ 不会发生调度的情况**

有些特殊场景**不允许调度**，否则会破坏系统稳定性：

- 在 **中断处理过程** 中（防止上下文切换影响中断处理）
- 在 **操作系统内核临界区** 中（避免数据结构不一致）
- 在 **原子操作指令执行过程中**

-----

**临界区的一般概念**

- 临界区 = 程序中访问 **共享资源** 的那段代码。
- 比如多个进程/线程访问一个共享变量、文件或缓冲区 → 就需要进入临界区，避免同时修改导致数据错乱。

------

**操作系统内核临界区**

- 指 **操作系统内核自己使用的关键数据结构** 所在的临界区。
- 例如：
  - 进程控制块（PCB）队列
  - 内存分配表
  - I/O 缓冲队列
- 这些数据是内核全局共享的，**如果被多个进程或中断同时修改，会导致内核数据结构损坏**。

所以，操作系统会在内核临界区中：

- **禁止调度**（不能切换进程）
- **禁止中断**（防止中断打断内核操作）

这样可以保证内核数据结构的一致性和安全性。

#### 进程调度的方式

进程调度的方式有两种，非剥夺调度方式和剥夺调度方式。

- 非剥夺调度方式(非抢占式): 只允许进程主动放弃处理机。
- 剥夺调度方式(抢占式): 当一个进程正在处理机上执行时，发现一个更重要的程序需要使用处理机，则立即暂停正在执行的程序，将处理机分配给更紧迫的那个进程。

#### 进程的切换与过程

进程的切换指操作系统把 **CPU 使用权** 从一个进程转移到另一个进程。

本质：保存当前进程的执行现场（上下文），再恢复另一个进程的上下文。

进程切换 = **保存当前进程现场 → 更新 PCB → 调度新进程 → 恢复新进程现场**。

注意，进程切换是有代价的，因此如果过于频繁的进行调度，切换，必然使系统的效率降低。

#### 调度器，闲逛进程

调度器是 **操作系统内核里的一个模块**，专门负责 **决定哪个进程获得 CPU 使用权**。负责挑选进程 → 谁上 CPU。

**闲逛进程**：当“没有人可挑”的时候，调度器就让闲逛进程上 CPU。

### 2.2.3 调度的目标

调度的目标(调度算法的评价指标)有CPU利用率，系统吞吐量，周转时间，等待时间，响应时间。

| 指标           | 含义                                | 目标（越好越怎样） | 适用场景               |
| -------------- | ----------------------------------- | ------------------ | ---------------------- |
| **CPU 利用率** | CPU 忙碌时间 ÷ 总时间               | 越高越好           | 批处理系统             |
| **系统吞吐量** | 单位时间内完成的作业数              | 越大越好           | 批处理系统             |
| **周转时间**   | 作业提交 → 完成的总时间             | 越短越好           | 批处理系统             |
| **等待时间**   | 作业在就绪队列里等待 CPU 的时间     | 越短越好           | 批处理系统、交互式系统 |
| **响应时间**   | 从用户提交请求 → 系统首次响应的时间 | 越短越好           | 交互式系统             |

### 2.2.4 调度算法

调度算法大致可以分为两类：

1. **适用于早期批处理系统（作业调度）的调度算法**
    这类算法主要关心对用户的公平性，如平均周转时间、平均等待时间等评价系统整体性能的指标，对于用户来说，交互性很差。典型算法包括：
   - **FCFS (先来先服务)** 
   - **SJF (短作业优先)**
   - **SRTN (最短剩余时间优先)**
   - **HRRN (高响应比优先)**

| 调度算法                | 算法思想                 | 算法规则                                            | 调度类型            | 是否抢占 | 优点                         | 缺点                                 | 是否会导致饥饿 |
| ----------------------- | ------------------------ | --------------------------------------------------- | ------------------- | -------- | ---------------------------- | ------------------------------------ | -------------- |
| FCFS (先来先服务)       | 按到达顺序执行           | 先到先服务，按到达时间排队执行                      | 作业调度 / 进程调度 | 非抢占   | 实现简单、公平               | 短作业可能等待时间长                 | 否             |
| SJF (短作业优先)        | 优先执行执行时间短的作业 | 按作业/进程长度排序，最短先执行                     | 作业调度 / 进程调度 | 非抢占   | 平均周转时间最短             | 可能饿死长作业，对执行时间估计要求高 | 是             |
| SRTN (最短剩余时间优先) | 抢占式 SJF               | 当前作业剩余时间比新到作业长时抢占                  | 作业调度 / 进程调度 | 抢占     | 平均周转时间更短，响应快     | 可能饿死长作业，切换频繁             | 是             |
| HRRN (高响应比优先)     | 优先执行响应比高的作业   | 响应比 = (等待时间 + 服务时间)/服务时间，选择最大者 | 作业调度 / 进程调度 | 非抢占   | 兼顾短作业和长作业，避免饥饿 | 计算响应比稍复杂                     | 否             |

2. **适用于交互式系统（进程调度）的调度算法**
    这类算法更注重系统的响应时间，公平性，平衡性等指标，典型算法包括：

- **RR (时间片轮转)**
- **优先级调度**
- **多级反馈队列调度**

| 调度算法        | 算法思想                               | 算法规则                                     | 调度类型            | 是否抢占 | 优点                               | 缺点                                  | 是否会导致饥饿 |
| --------------- | -------------------------------------- | -------------------------------------------- | ------------------- | -------- | ---------------------------------- | ------------------------------------- | -------------- |
| RR (时间片轮转) | 轮流分配 CPU 时间                      | 每个作业按时间片轮流执行，时间片用完换下一个 | 进程调度            | 抢占     | 公平，响应时间好，适合分时操作系统 | 时间片太大退化为 FCFS，太小切换开销大 | 否             |
| 优先级调度      | 优先级高的作业先执行                   | 根据作业或进程优先级选择下一个执行           | 作业调度 / 进程调度 | 可抢占   | 可以保证重要作业先执行             | 低优先级可能长期等待                  | 是             |
| 多级反馈队列    | 多个队列，不同优先级和时间片，动态调整 | 作业可在队列间移动，长作业逐渐降低优先级     | 进程调度            | 抢占     | 兼顾响应时间和公平性，适合混合负载 | 实现复杂                              | 是             |

### 2.2.5 多处理机调度

![image-20250819183112860](https://cdn.jsdelivr.net/gh/Kxq-xl/pic-bed/img/image-20250819183112860.png)

在多处理机应该追求的目标: **负载均衡**和**处理机亲和**。

- 负载均衡：尽可能让每个CPU都同等忙碌
- 处理机亲和性: 尽量让一个进程调度到同一个CPU上运行，让发挥CPU发中缓存的作用。

解决负载均衡和亲和性有两种方案。

#### 方案一 公共有序队列

- 所有CPU共享同一个就绪进程队列（位于内核区）
- 每个CPU时运行调度程序，从公共就绪队列中选择一个进程与运行。
- 每个CPU访问公共就绪队列时需要上锁（确保互斥）

- [x] 优点：可以天然的实现负载均衡

- [ ] 缺点：各个进程频繁切换CPU，‘亲和性’不好。

❓如何解决亲和性问题呢？

**软亲和**：进程**尽可能**在原 CPU 上运行，但可以迁移到其他 CPU

**硬亲和**：进程**必须**在指定 CPU 上运行，不允许迁移

#### 方案二 私有就绪队列 

- 每个CPU都有一个私有就绪队列
- CPU空闲时运行调度程序，从私有就绪队列中选择一个进程运行。

- [x] 优点：可以天然的实现亲和性

- [ ] 缺点：初始负载不均衡时，可能出现某些 CPU 队列空闲、某些 CPU 队列繁忙。

❓如何解决队列空闲或者队列繁忙呢？

**推迁移(push)** : 当发现别的CPU空闲，而一个很忙，就会从忙碌的CPU中推一些给空闲的CPU的就绪队列中。

**拉迁移(pull)** :  当发现CPU负载很低，就会从高负载的CPU的就绪队列中拉一些进程到自己的就绪队列。

![image-20250819190641935](https://cdn.jsdelivr.net/gh/Kxq-xl/pic-bed/img/image-20250819190641935.png)

---

### 2.3 进程同步与互斥

#### 2.3.1 互斥和同步的基本概念

**1. 进程互斥（Mutual Exclusion）**

**概念**：

- 当多个进程需要访问**同一共享资源**（如内存数据、文件、打印机等）时，为了防止同时访问导致数据混乱，需要确保**在同一时间只有一个进程访问该资源**。
- 这个保证“同一时刻只有一个进程访问资源”的机制，就叫**互斥**。

进程互斥经典的临界区互斥模型，是由进入区，临界区，退出区，剩余区实现的，需要遵循空闲让进，忙则等待，有限等待，让权等待，这四个原则。

**举例**：

- 两个进程同时要修改银行账户余额，如果不加互斥，可能出现“钱多扣少加”的错误。互斥就保证了每次只有一个进程能修改账户余额。

------

**2. 进程同步（Process Synchronization）**

**概念**：

- 当多个进程之间存在**执行顺序依赖**时，需要保证进程按照某种顺序执行，这种协调机制叫**同步**。
- 简单来说，**同步是为了顺序正确，互斥是为了防止资源冲突**。

**举例**：

- 生产者-消费者问题：
  - 生产者先生产数据，再让消费者消费；
  - 消费者必须等到有数据才能消费。
- 这里就是同步：保证先后顺序正确。

| 特性     | 进程互斥             | 进程同步                   |
| -------- | -------------------- | -------------------------- |
| 目的     | 防止共享资源冲突     | 保证执行顺序正确           |
| 关注点   | **同一时间访问冲突** | **先后执行顺序**           |
| 常用机制 | 锁、信号量、临界区   | 信号量、条件变量、消息队列 |
| 举例     | 银行账户操作         | 生产者-消费者问题          |

![image-20250820162347481](https://cdn.jsdelivr.net/gh/Kxq-xl/pic-bed/img/image-20250820162347481.png)

#### 2.3.2 互斥的实现方法

##### 软件实现方法

- 单标志法：

算法思想：两个进程在**访问完临界区后**会把使用临界区的**权限交给另一个进程**，也就是说每个进程进入临界区的权限**只能被另一个进程赋予**。

![image-20250820163857169](https://cdn.jsdelivr.net/gh/Kxq-xl/pic-bed/img/image-20250820163857169.png)

但是如果此时轮到P0进程使用，但P0一直不使用(占着茅坑不拉屎)，而P1要用却进不去了。

所以**违背了“空闲让进”原则**。

- 双标志先检查：

算法思想：设置一个布尔数组`flag[]`,数组中各个元素用来标记个进程想进入临界区的意愿。`flag[0] = true` 表示P0进程想进入临界区，`flag[1] = false` 表示P1进程不想进入临界区。

![image-20250820164558320](https://cdn.jsdelivr.net/gh/Kxq-xl/pic-bed/img/image-20250820164558320.png)

但是进入区的检查和上锁两个处理不是一气呵成的，先检查后，上锁前可能会发生进程切换。此时就是同时访问临界区了。

所以**违背了“忙则等待”原则**。

- 双标志后检查：

算法思想: 双标志先检查的改版，因为上一个算法是先**检查后上锁**，无法一气呵成，所以人们又想到了先**上锁后检查**。

![image-20250820170549132](https://cdn.jsdelivr.net/gh/Kxq-xl/pic-bed/img/image-20250820170549132.png)

虽然解决了"忙则等待"的问题，但是很有可能会发生一直卡在2 6 代码处，两个进程都想进入临界区，但是谁也不让谁，会因各进程都长期无法访问临界资源产生"饥饿"。

所以又**违背了"空闲让进"和"有限等待"**的原则。

Peterson 算法：结合双标志法，单标志法的思想，如果双方都争着想进入临界区，那可以让进程尝试"孔融让梨" 做一个有礼貌的进程。

![image-20250820171615508](https://cdn.jsdelivr.net/gh/Kxq-xl/pic-bed/img/image-20250820171615508.png)

这个算法遵循了空闲让进，忙则等待，有限等待 三个原则，但是它如果进不了临界区，它会一直卡在while循环，一直在CPU上执行，占用CPU资源。

所以违背了“让权等待”的原则。

![image-20250820182111043](https://cdn.jsdelivr.net/gh/Kxq-xl/pic-bed/img/image-20250820182111043.png)

##### 硬件实现方法

- 中断屏蔽方法：

利用"开/关中断指令"实现，强制的，不允许发生进程切换，因此不会发生两个同时访问临界区的情况。

![image-20250820183530045](https://cdn.jsdelivr.net/gh/Kxq-xl/pic-bed/img/image-20250820183530045.png)

优点：简单，高效

缺点：不适用于多处理机，只适用于操作系统内核进程，不适用于用户进程(用户随便开关中断指令，很危险)



- TestAndSet(TS指令/TSL指令)

简称TS指令，这个指令使用**硬件实现**的，执行的过程不允许中断，只能一气呵成。

![image-20250820184614962](https://cdn.jsdelivr.net/gh/Kxq-xl/pic-bed/img/image-20250820184614962.png)

这个和Peterson算法一样，违背了**“让权等待”**的原则。

-  

![image-20250820185014239](https://cdn.jsdelivr.net/gh/Kxq-xl/pic-bed/img/image-20250820185014239.png)

这个和TS指令的思路几乎一致，缺点也一致。 

![image-20250820185322588](https://cdn.jsdelivr.net/gh/Kxq-xl/pic-bed/img/image-20250820185322588.png)

#### 2.3.3 互斥锁

**互斥锁的目的**

- **核心目标**：保护 **临界区（Critical Section）**，防止多个进程/线程同时修改共享资源而产生 **竞态条件（Race Condition）**。
- **实现方式**：通过锁机制，让一次只有一个进程进入临界区。

 **自旋锁（Spinlock）**

自旋锁，是互斥锁的一种实现方式，尤其适合 **多处理器系统**。

特点：

1. **忙等待**：如果锁被占用，线程 **不会被挂起**，而是在 CPU 上循环检查锁是否释放 → 这叫“自旋”。
2. **低延迟**：多核系统下，如果锁很快释放，线程能立即进入临界区，比阻塞锁（挂起等待）效率高。
3. **占用 CPU**：自旋等待期间，CPU 一直在检查锁，**浪费 CPU**，不适合长时间持锁。

使用场景：

- **多核 CPU**，临界区很短 → 自旋锁很快就能获取锁
- **临界区很长或单核 CPU** → 不推荐自旋锁，应该使用阻塞锁

| 特性     | 自旋锁                   | 阻塞锁（传统互斥锁）       |
| -------- | ------------------------ | -------------------------- |
| CPU 消耗 | 会占用 CPU（忙等待）     | 不占用 CPU（挂起等待）     |
| 延迟     | 低，锁释放立即获取       | 高，线程被挂起和唤醒有开销 |
| 使用场景 | 多核、临界区短           | 单核或临界区长             |
| 实现     | 基于原子操作（TSL/Swap） | 基于操作系统调度           |