# 1. 操作系统概述

## 1.1 操作系统的基本概念

###  1.1.1 操作系统的概念

**操作系统是计算机的“管理者”和“中介”**，它负责协调和控制计算机的各种资源（如 CPU、内存、硬盘、输入输出设备等），同时向上为用户和程序提供一个**友好、统一的操作接口**。

**常见功能包括：**

1. **进程管理**：
    管理程序的运行，包括进程创建、调度、终止等。
2. **内存管理**：
    控制和分配内存资源，确保各程序合理使用内存，互不干扰。
3. **文件系统**：
    提供文件的创建、读写、存储等功能，便于数据管理。
4. **设备管理**：
    管理各种输入输出设备，如硬盘、打印机、键盘等。
5. **用户接口**：
    提供命令行或图形界面，让用户能与计算机交互。

常见的操作系统有: **Windows ** **Linux ** **macOS ** **Android / iOS（移动设备）**

### 1.1.2 操作系统的功能和目标

操作系统作为计算机系统资源的管理者

- 处理机管理
- 存储器管理
- 文件管理
- 设备管理

![image-20250807183551941](https://cdn.jsdelivr.net/gh/Kxq-xl/pic-bed/img/image-20250807183551941.png)

![image-20250807185430547](https://cdn.jsdelivr.net/gh/Kxq-xl/pic-bed/img/image-20250807185430547.png)

### 1.1.3 操作系统的特征

操作系统的特称： 并发 ，共享，虚拟，异步。

- **并发:**  指两个或者多个事件在同一时间间隔内发生，这些事件**宏观上是同时发生的**，但**微观上是交替发生的**。并行：是指两个时间在同一时刻同时发生。

![image-20250807191349209](https://cdn.jsdelivr.net/gh/Kxq-xl/pic-bed/img/image-20250807191349209.png)

**注意:**

单核CPU**同一时刻只能执行一个程序**，各个程序**并发**的执行。

多核CPU**同一时刻能执行多个程序**，多个程序可以**并行**执行。

- **共享**：共享即多个事件发生的时候，共同使用。资源共享主要分为**互斥共享**和**同时共享**。

微信和qq不能同时视频，这个就是互斥共享，不能同时占用摄像头。

但是可以同时发送文件，同时发送文件在宏观上是同时读取，同时发送，但并不是同时共享，它在微观上，两个进程是交替着访问硬盘的，这里传一会儿，那里传一下。所以磁盘是可共享资源，但访问是以并发+交替调度方式进行的

我们如果一遍打游戏，一遍听歌，这个扬声器确实是同时共享

**并发和共享是互为存在的条件**，只有并发了你才可以共享，你共享了，就必须并发才行。

- **虚拟： **把一个物理上的实体变为若干个逻辑上的对应物。物理实体(前者)是实际存在的，而逻辑上对应物（后者）是用户感受到的。

比如4g的内存，但你却能打开好多程序，他们运行内存远远大于4gb，这就是虚拟存储器技术。实际上只有4g，但用户看起来很大。 ------ 空分复用技术。

比如我们一个单核的CPU，物理上我们只能打开一个程序，但是逻辑上我们仍然可以打开很多很多的程序。 ----- 时分复用技术。

 ![image-20250807194931611](https://cdn.jsdelivr.net/gh/Kxq-xl/pic-bed/img/image-20250807194931611.png)

- **异步：**在多道程序环境下，允许多个程序并发执行，但由于资源有限，进程的执行不是一贯到底的，而是走走停停，以不可预知的速度向前推进，这就是进程的异步性。

你需要打印文档A和B, 总有个先后，先打印A B则等待，系统资源有限，因此进程的执行不是一贯到底的。

## 1.2 操作系统的发展与分类

![image-20250808153041562](https://cdn.jsdelivr.net/gh/Kxq-xl/pic-bed/img/image-20250808153041562.png)

## 1.3 操作系统的运行环境

### 1.3.1 操作系统的运行机制

在操作系统中，cpu上会运行两种程序，一种是操作系统的**内核程序**，另一种是用户编写的**应用程序**。

**两种指令:**

- 特权指令: 是指不允许用户直接使用的指令，I/O指令，内存清零，修改程序状态寄存器等指令
- 非特权指令: 用户可以直接使用的指令，它不能直接访问系统的软硬件资源，防止破坏系统。

两种处理器状态：

- 内核态：运行的是内核程序，此时可以执行特权指令

- 用户态： 运行的是应用程序，只能执行非特权指令。

CPU中有一个寄存器叫做程序状态字寄存器(psw) 其中有一个二进制位，`1`表示内核态` 0`表示用户态。有些 CPU 设计是反过来的（比如 `0` 表示内核态，`1` 表示用户态），**具体取值要看 CPU 架构手册**。

![image-20250808161040012](https://cdn.jsdelivr.net/gh/Kxq-xl/pic-bed/img/image-20250808161040012.png)

### 1.3.2 中断和异常

在合适的情况下，操作系统内核会把cpu的使用权主动让给应用程序。

中断是让操作系统给内核夺回cpu使用权的**唯一途径**，中断会使cpu由用户态变为内核态。

中断分为**内中断（异常）**和**外中断**

- 内中断: 与当前执行的指令有关，中断信号来源于cpu内部。

试图在用户态下执行特权指令，当前的指令是非法的(**终止**)，或者参数是非法的(**故障**)。

应用程序想请求操作系统内核服务，此时会执行一条**陷入指令**，该指令会引发一个内部中断信号，**系统调用就是通过陷入指令完成的**。

- 外中断: 与当前执行的指令无关，中断信号来源于cpu外部。

时钟中断，I/O中断。

![image-20250808170047574](https://cdn.jsdelivr.net/gh/Kxq-xl/pic-bed/img/image-20250808170047574.png)

### 1.3.3 系统调用

系统调用是操作系统提供给程序(程序员)使用的接口。

系统调用的功能:

- 设备管理
- 文件管理
- 进程控制
- 进程通信
- 内存管理

![image-20250808172557614](https://cdn.jsdelivr.net/gh/Kxq-xl/pic-bed/img/image-20250808172557614.png)

![image-20250808172624360](https://cdn.jsdelivr.net/gh/Kxq-xl/pic-bed/img/image-20250808172624360.png)

## 1.4 操作系统体系结构

操作系统的体系结构有大内核(宏内核)，微内核，分层结构，模块化，外核。

- 分层结构： 每层单向调用更低一层所提供的接口，便于调试，易维护，但是效率低，不可跨层调用，效率低。
- 模块化：每个模块之间相互独立，有着清晰的结构，但是模块之间可能会出现相互调用的情况，一旦出了问题，调试和验证会有点麻烦。
- 大内核:  高性能，但是结构混乱，难以维护
- 微内核： 内核功能少，方便维护，但是多次状态切换，性能低。
- 外核: 可以直接给用户进程分配不虚拟不抽象的硬件资源，使用户进程更灵活的使用硬件资源，但它降低了系统的一致性，使系统变得复杂。

![image-20250811174934154](https://cdn.jsdelivr.net/gh/Kxq-xl/pic-bed/img/image-20250811174934154.png)

![image-20250811175156226](https://cdn.jsdelivr.net/gh/Kxq-xl/pic-bed/img/image-20250811175156226.png)

## 1.5 操作系统的引导

计算机中的主存由RAM(内存)和ROM组成。

| 对比项       | RAM（内存）              | ROM（只读存储器）                |
| ------------ | ------------------------ | -------------------------------- |
| 是否可写     | 读写都行（运行时可改）   | 一般只读（某些可擦写）           |
| 断电是否丢失 | 丢失（易失性）           | 不丢失（非易失性）               |
| 速度         | 很快                     | 较慢                             |
| 主要用途     | 存放正在运行的程序和数据 | 存放启动程序和固件(BIOS)自举程序 |
| 位置         | 内存条8G, 16G 32G        | 焊在主板上的芯片                 |

开机通电，cpu去找主存，然后里面的ROM引导程序会指示cpu去磁盘首位置将主引导记录和分区表读入到RAM(内存中去) 

然后cpu执行磁盘引导程序，然后根据分区表，去判断C盘所处的位置，然后在C盘中找到引导记录PBR，它会负责找到启动管理，在根目录下找到启动管理程序，然后就会完成操作系统初始化的工作。

![image-20250811194744778](https://cdn.jsdelivr.net/gh/Kxq-xl/pic-bed/img/image-20250811194744778.png)

## 1.6 虚拟机

![image-20250812105818489](https://cdn.jsdelivr.net/gh/Kxq-xl/pic-bed/img/image-20250812105818489.png)



## 总结：✅ **操作系统第1章 速记表**

### **1. 操作系统的定义与作用**

- **定义**：操作系统是管理计算机硬件与软件资源、提供用户和程序接口的系统软件。
- **作用**：
  1. 作为**用户与硬件的接口**（命令行、GUI）
  2. 作为**资源管理者**（CPU、内存、文件、设备等）
  3. 提供**服务**（系统调用、库函数）

------

### **2. 操作系统的特征**

- **并发性**：多个程序宏观上同时运行，微观上分时交替执行。
- **共享性**：系统资源可被多个用户或程序共同使用（互斥共享 & 同时共享）。
- **虚拟性**：通过抽象技术，让有限资源看起来更大或更简单（如虚拟内存、虚拟处理器）。
- **异步性**：进程执行走走停停，由 OS 调度，但结果可预测。

------

### **3. 操作系统的主要功能**

1. **进程管理**：进程/线程控制、调度、同步与通信。
2. **存储管理**：内存分配与回收、虚拟内存管理。
3. **文件管理**：文件存储、目录管理、访问控制。
4. **设备管理**：设备分配、驱动程序、中断处理。

------

### **4. 系统调用 vs API**

- **系统调用（System Call）**：
  - OS 提供给用户程序访问内核功能的**唯一接口**。
  - 通过陷入指令从用户态切换到内核态执行。
  - 例：`read()`, `write()`, `fork()`（Linux）
- **API（Application Programming Interface）**：
  - 应用程序调用的**函数接口**，可能封装了系统调用。
  - 例：C 标准库函数 `printf()` 内部会调用 `write()` 系统调用。
- **关系**：
   API 是高层接口，系统调用是 OS 提供的底层接口；API 可以调用系统调用，但不等于系统调用。
### **5. 并发 vs 并行**

- **并发（Concurrency）**：宏观同时、微观交替执行（单核 CPU 也能做到）。
- **并行（Parallelism）**：真正的同时执行（需要多核/多处理器）。

例子：

- 并发：一个 CPU 交替处理两个进程，看起来像同时进行。
- 并行：两个 CPU 核心分别同时执行两个进程。

------

### **6. 操作系统如何实现虚拟？**

- **虚拟内存**：用磁盘空间扩展物理内存，并给进程提供连续的地址空间抽象。
- **虚拟处理器**：多道程序设计，让每个进程看起来像独占 CPU。
- **虚拟设备**：用统一接口（驱动 + 虚拟文件系统）操作不同物理设备。

---

# 2. 进程管理

## 2.1 进程和线程

### 2.1.1 进程的概念和组成

- 程序: 放在磁盘里面的可执行文件，是==静态==的。

- 进程: 是程序的一次执行过程， 是==动态==的。

当一个进程被创建的时候，操作系统会为此程序创建一个**唯一**的，**不重复**的ID --- **PID**。

**UID** 就是进程所属的用户。

![image-20250813164833849](https://cdn.jsdelivr.net/gh/Kxq-xl/pic-bed/img/image-20250813164833849.png)

上面所说的PID UID 以及图片中的cpu，磁盘，内存等等 都需要放在一个**进程控制块中(PCB)** PCB是进程存在的**唯一标志**。

![image-20250813165156689](https://cdn.jsdelivr.net/gh/Kxq-xl/pic-bed/img/image-20250813165156689.png)

**进程的组成: ** PCB、程序段、数据段。

PCB，是给操作系统用的，程序段和数据段是进程给自己用的。	

![image-20250813165918923](https://cdn.jsdelivr.net/gh/Kxq-xl/pic-bed/img/image-20250813165918923.png)

程序段、数据段、PCB三部分组成了进程实体(进程映像)。

进程是进程实体的运行过程，是系统进行资源分配和调度的一个单位。

### 2.1.2 进程的特征

程序是静态的，进程是动态的，相比于程序，进程拥有一下特征：

- 动态性：进程是程序的一次执行过程，是动态产生的，变化和消亡的。
- 并发性：内存中有个进程实体，各进程可以并发执行。
- 独立性：进程是能独立运行，独立获得资源，独立接受调度的基本单位
- 异步性：各进程各自独立的，不可预知的速度向前推进
- 结构性：每个进程都配置一个PCB，都由程序段和数据段 PCB组成。

### 2.1.3 进程的状态与转化

![image-20250813171633226](https://cdn.jsdelivr.net/gh/Kxq-xl/pic-bed/img/image-20250813171633226.png)

**状态：**

- 创建态：进程正在被创建，这个阶段操作系统会为进程分配资源，初始化PCB。
- 就绪态：进程已经创建完毕了，但由于没有空闲的CPU，就暂时不运行。
- 运行态：当CPU空闲下来，操作系统就会从处于就绪态的进程中，选择一个，进行运行，就叫运行态。
- 阻塞态：在进程运行中，有可能会**请求某个事件的发生**，所以在这个事件发生之前，CPU会使这个进程下去，让他变位阻塞态，然后CPU再选择一个就绪态的进程。当它等待的事情发生后，这个进程就又变回就绪态。
- 终止态：一个进程执行`exit` 请求操作系统终止进程，此时进程进入了终止态，然后让该进程下CPU，并回收内存空间等资源，最后回收PCB。

![image-20250813174231156](https://cdn.jsdelivr.net/gh/Kxq-xl/pic-bed/img/image-20250813174231156.png)

### 2.1.4 进程控制

进程控制就是 OS 用**原语**通过 PCB 对进程的**创建、运行、阻塞、唤醒、终止**进行管理，确保多进程在系统中**安全、高效、有序**地运行。

原语的执行必须一气呵成，不可中断。

**进程的创建**

- 分配进程控制块（PCB）
- 分配所需的内存和资源
- 初始化寄存器、程序计数器等运行环境
- 典型调用：`fork()`（Linux）

**进程的终止**

- 回收资源（内存、文件描述符等）
- 销毁 PCB
- 通知父进程进程结束状态

**进程的阻塞与唤醒**（成对出现）

- **阻塞**：进程等待某个事件（I/O 完成、信号等）而暂停运行
- **唤醒**：事件发生后让阻塞进程重新进入就绪队列

**进程的切换（上下文切换）**

- 保存当前进程的 CPU 环境（寄存器值、程序计数器等）
- 恢复下一个进程的运行环境

| 控制动作              | PCB 状态变化                       | 队列变化         |
| --------------------- | ---------------------------------- | ---------------- |
| **创建**（Create）    | 新建 PCB → 初始化状态              | 加入**就绪队列** |
| **撤销**（Terminate） | 释放 PCB → 回收资源                | 从所有队列移除   |
| **阻塞**（Block）     | 状态改为阻塞                       | 移入**阻塞队列** |
| **唤醒**（Wakeup）    | 状态改为就绪                       | 加入**就绪队列** |
| **切换**（Dispatch）  | 保存当前 PCB 寄存器值 → 加载新 PCB | 运行队列切换     |

无论哪个进程控制原语，要做的无非三类事情。

1. 更新PCB中信息
2. 将PCB插入合适的队列
3. 分配/回收资源

进程控制 = **PCB + 原语 + 队列管理**

### 2.1.5 进程通信(IPC)

进程间通信就是指两个进程或者多个进程之间产生的数据交互，

- 高级通信: **共享存储**，**消息传递**，**管道通信**, **套接字（Socket)(网络通信机制)**
- 低级通信: **信号量**，**信号**。

#### **高级通信**（侧重数据传输）

**共享存储：**

- 基于**数据结构**的共享：规定的类型，规定的长度，这种方式速度慢，限制多，是一种**低级通信**方式
- 基于**存储区**的共享：操作系统在内存中划出一块共享存储区，数据形式，存放位置都由进程控制，这种方式速度快，是一种**高级通信**方式。

**消息传递：**

- **直接通信**方式：消息发送进程要指明接受进程的ID

![image-20250814171206892](https://cdn.jsdelivr.net/gh/Kxq-xl/pic-bed/img/image-20250814171206892.png)

- **间接通信**方式：通过"信箱"间接地通信,可以多个进程往同一个信箱send消息，也可以从多个进程receive消息。

![image-20250814174123208](https://cdn.jsdelivr.net/gh/Kxq-xl/pic-bed/img/image-20250814174123208.png)

**管道通信：** 管道通信的管道是一个先进先出的队列(循环队列）。

- 管道的数据流向是一个单向的，称为**半双工通信**

![image-20250814180128171](https://cdn.jsdelivr.net/gh/Kxq-xl/pic-bed/img/image-20250814180128171.png)

- 如果要实现双向同时通信，则需要两个管道，称为**全双工通信**。

![image-20250814180025519](https://cdn.jsdelivr.net/gh/Kxq-xl/pic-bed/img/image-20250814180025519.png)

1. 各个进程要**互斥的**访问管道。
2. 当**管道写满**时，写进程将**阻塞**，直到读进程将管道的数据取走，即可唤醒写进程。
3. 当**管道读空**时，读进程将**阻塞**，直到写进程往管道中写入数据，就可唤醒读进程。

![image-20250814180927052](https://cdn.jsdelivr.net/gh/Kxq-xl/pic-bed/img/image-20250814180927052.png)

#### **低级通信**（侧重同步 & 事件通知）

- 信号量 - 实现进程的同步，互斥。
- 信号 - 实现进程间通信。

信号用于通知进程某个特定的事件已经发生。进程收到一个信号后，对该信号进行处理。

1️⃣ 什么是信号

- 信号是**软件中断**，用于通知进程发生了某种事件。
- 可以由 **内核** 或 **其他进程** 发送。
- 被发送的进程**不需要提前等着**，它会在执行过程中被打断去处理信号，所以叫**异步**。

------

2️⃣ 信号的来源

1. **内核产生**
   - 硬件异常：除零错误 → `SIGFPE`
   - 访问非法内存：`SIGSEGV`
   - 子进程结束：`SIGCHLD`
2. **用户进程产生**
   - 通过系统调用 `kill()` 给某进程发信号
   - 通过终端快捷键：
     - `Ctrl+C` → `SIGINT`（中断）
     - `Ctrl+Z` → `SIGTSTP`（暂停）

------

3️⃣ 信号的常见类型（Linux）

| 信号名    | 编号 | 含义                               |
| --------- | ---- | ---------------------------------- |
| `SIGINT`  | 2    | 终端中断（Ctrl+C）                 |
| `SIGKILL` | 9    | 强制杀死进程（不可捕获、不可忽略） |
| `SIGTERM` | 15   | 终止进程（可处理）                 |
| `SIGSTOP` | 19   | 暂停进程（不可捕获）               |
| `SIGSEGV` | 11   | 段错误（非法内存访问）             |

------

4️⃣ 信号的处理方式

每当从内核态要转为用户态时，就会处理这些信号，进程可以选择：

1. **执行默认动作**（比如终止、暂停等）
2. **捕获信号**（自定义**信号处理函数**去处理）
3. **忽略信号**（除 `SIGKILL` 和 `SIGSTOP` 外）

------

5️⃣ 信号的作用

- **进程控制**：杀死、暂停、恢复进程
- **事件通知**：告诉进程某事件发生（如 I/O 完成）
- **错误处理**：异常情况立即打断进程执行

------

📌 **一句话记忆**
 信号 = 软件世界的“快递员”，异步送来事件通知，让进程立即响应，常用于控制和通知。

